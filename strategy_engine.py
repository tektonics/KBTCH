"""
Simple strategy engine for Kalshi BTC binary options trading.
Focuses on BRTI vs market price divergence opportunities.
"""

import time
import logging
from typing import Dict, Any, Optional, List
from dataclasses import dataclass
from event_bus import event_bus, EventTypes
from config.config_manager import config

logger = logging.getLogger(__name__)


@dataclass
class Signal:
    """Trading signal generated by strategy"""
    market_ticker: str
    signal_type: str  # "BUY_YES", "BUY_NO", "SELL_YES", "SELL_NO"
    confidence: float  # 0.0 to 1.0
    strike_price: float
    current_brti: float
    market_yes_price: float
    market_no_price: float
    reason: str
    timestamp: float


class StrategyEngine:
    """Simple BRTI divergence strategy"""
    
    def __init__(self):
        self.strategy_settings = config.get_strategy_settings()
        
        # Strategy parameters (can be moved to config later)
        self.min_divergence_pct = 0.02  # 2% minimum divergence to trade
        self.max_divergence_pct = 0.20  # 20% max divergence (sanity check)
        self.min_confidence = 0.5  # Minimum signal confidence to trade
        
        # Internal state
        self.current_brti: Optional[float] = None
        self.active_markets: Dict[str, Dict] = {}
        self.last_signal_time: Dict[str, float] = {}
        self.min_signal_interval = 1.0  # Minimum seconds between signals for same market
        
        # Subscribe to relevant events
        event_bus.subscribe(EventTypes.MARKET_DATA_UPDATE, self._handle_market_data)
        event_bus.subscribe(EventTypes.PRICE_UPDATE, self._handle_price_update)
        
        logger.info("Strategy Engine initialized")
    
    def _handle_market_data(self, event) -> None:
        """Handle market data updates from KMS"""
        try:
            data = event.data
            market_ticker = data.get("market_ticker")
            
            if not market_ticker:
                return
            
            # Store market data
            self.active_markets[market_ticker] = {
                "ticker": market_ticker,
                "yes_bid": data.get("yes_bid"),
                "yes_ask": data.get("yes_ask"),
                "no_bid": data.get("no_bid"),
                "no_ask": data.get("no_ask"),
                "strike_price": data.get("strike_price"),
                "timestamp": time.time()
            }
            
            # Check for signals if we have BRTI data
            if self.current_brti:
                self._check_for_signals(market_ticker)
                
        except Exception as e:
            logger.error(f"Error handling market data: {e}")
    
    def _handle_price_update(self, event) -> None:
        """Handle BRTI price updates from UDM"""
        try:
            data = event.data
            if "brti_price" in data:
                self.current_brti = data["brti_price"]
                
                # Check all active markets for signals
                for market_ticker in self.active_markets.keys():
                    self._check_for_signals(market_ticker)
                    
        except Exception as e:
            logger.error(f"Error handling price update: {e}")
    
    def _check_for_signals(self, market_ticker: str) -> None:
        """Check if market conditions generate a trading signal"""
        try:
            market_data = self.active_markets.get(market_ticker)
            if not market_data or not self.current_brti:
                return
            
            # Rate limiting - don't generate signals too frequently for same market
            now = time.time()
            last_signal = self.last_signal_time.get(market_ticker, 0)
            if now - last_signal < self.min_signal_interval:
                return
            
            strike_price = market_data["strike_price"]
            yes_bid = market_data["yes_bid"]
            yes_ask = market_data["yes_ask"]
            no_bid = market_data["no_bid"]
            no_ask = market_data["no_ask"]
            
            # Skip if missing critical data
            if None in [strike_price, yes_bid, yes_ask, no_bid, no_ask]:
                return
            
            # Calculate theoretical probability based on BRTI
            # If BRTI > strike, YES should be worth more, NO should be worth less
            distance_from_strike = self.current_brti - strike_price
            distance_pct = abs(distance_from_strike) / strike_price
            
            # Calculate market implied probability
            yes_mid = (yes_bid + yes_ask) / 2
            market_prob = yes_mid / 100  # Convert cents to probability
            
            # Simple signal logic - both BUY and SELL signals
            signal = None
            
            if distance_from_strike > 0:  # BRTI above strike
                # YES should be worth close to 100¢, so buy YES if it's cheap
                if yes_ask < 90 and distance_pct > self.min_divergence_pct:
                    confidence = min(distance_pct * 5, 1.0)  # Scale confidence
                    if confidence >= self.min_confidence:
                        signal = Signal(
                            market_ticker=market_ticker,
                            signal_type="BUY_YES",
                            confidence=confidence,
                            strike_price=strike_price,
                            current_brti=self.current_brti,
                            market_yes_price=yes_ask,
                            market_no_price=no_bid,
                            reason=f"BRTI ${self.current_brti:,.0f} > strike ${strike_price:,.0f}, YES underpriced at {yes_ask}¢",
                            timestamp=now
                        )
                
                # If you own NO positions, consider selling since BRTI suggests YES should win
                elif no_bid > 10 and distance_pct > self.min_divergence_pct:
                    confidence = min(distance_pct * 5, 1.0)
                    if confidence >= self.min_confidence:
                        signal = Signal(
                            market_ticker=market_ticker,
                            signal_type="SELL_NO",
                            confidence=confidence,
                            strike_price=strike_price,
                            current_brti=self.current_brti,
                            market_yes_price=yes_ask,
                            market_no_price=no_bid,
                            reason=f"BRTI ${self.current_brti:,.0f} > strike ${strike_price:,.0f}, exit NO positions at {no_bid}¢",
                            timestamp=now
                        )
            
            else:  # BRTI below strike
                # NO should be worth close to 100¢, so buy NO if it's cheap
                if no_ask < 90 and distance_pct > self.min_divergence_pct:
                    confidence = min(distance_pct * 5, 1.0)
                    if confidence >= self.min_confidence:
                        signal = Signal(
                            market_ticker=market_ticker,
                            signal_type="BUY_NO",
                            confidence=confidence,
                            strike_price=strike_price,
                            current_brti=self.current_brti,
                            market_yes_price=yes_mid,
                            market_no_price=no_ask,
                            reason=f"BRTI ${self.current_brti:,.0f} < strike ${strike_price:,.0f}, NO underpriced at {no_ask}¢",
                            timestamp=now
                        )
                
                # If you own YES positions, consider selling since BRTI suggests NO should win
                elif yes_bid > 10 and distance_pct > self.min_divergence_pct:
                    confidence = min(distance_pct * 5, 1.0)
                    if confidence >= self.min_confidence:
                        signal = Signal(
                            market_ticker=market_ticker,
                            signal_type="SELL_YES",
                            confidence=confidence,
                            strike_price=strike_price,
                            current_brti=self.current_brti,
                            market_yes_price=yes_bid,
                            market_no_price=no_ask,
                            reason=f"BRTI ${self.current_brti:,.0f} < strike ${strike_price:,.0f}, exit YES positions at {yes_bid}¢",
                            timestamp=now
                        )
            
            # Publish signal if generated
            if signal and distance_pct <= self.max_divergence_pct:
                self._publish_signal(signal)
                self.last_signal_time[market_ticker] = now
                
        except Exception as e:
            logger.error(f"Error checking signals for {market_ticker}: {e}")
    
    def _publish_signal(self, signal: Signal) -> None:
        """Publish trading signal to event bus"""
        try:
            event_data = {
                "market_ticker": signal.market_ticker,
                "signal_type": signal.signal_type,
                "confidence": signal.confidence,
                "strike_price": signal.strike_price,
                "current_brti": signal.current_brti,
                "market_yes_price": signal.market_yes_price,
                "market_no_price": signal.market_no_price,
                "reason": signal.reason,
                "timestamp": signal.timestamp
            }
            
            event_bus.publish(
                EventTypes.SIGNAL_GENERATED,
                event_data,
                source="strategy_engine"
            )
            
            logger.info(f"Signal: {signal.signal_type} {signal.market_ticker} "
                       f"(confidence: {signal.confidence:.2f}) - {signal.reason}")
            
        except Exception as e:
            logger.error(f"Error publishing signal: {e}")
    
    def get_status(self) -> Dict[str, Any]:
        """Get strategy engine status"""
        return {
            "current_brti": self.current_brti,
            "active_markets": len(self.active_markets),
            "last_signal_times": self.last_signal_time.copy(),
            "parameters": {
                "min_divergence_pct": self.min_divergence_pct,
                "max_divergence_pct": self.max_divergence_pct,
                "min_confidence": self.min_confidence
            }
        }
